# -*- coding: utf-8 -*-
"""Genetic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DezLefsusORxbKD0omN_xFqF_o28POZ7
"""

import numpy as np
import random
import statistics as st
import math

popSize = 100
generation = 40

#----init population----
def init_pop():
    Population = np.zeros((popSize,6))
    for i in range (popSize):
        Population[i] = np.random.rand(6)
        for j in range (1,6):
           if (j % 5 == 0):
              Population[i][j] =  math.ceil(90 * Population[i][j] + 10)
    return Population
    chrom_size = len(Population[0])

Population = init_pop()
print(Population)
chrom_size = len(Population[0])
print(chrom_size)

#----parent selection----
def parent_selection():
    muRate = 0.1
    crossRate = 0.3
    muPop_size = int(np.ceil(muRate * popSize))
    crossPop_size = 2*(2*np.ceil(crossRate * popSize)/2)
    childPop_size = muPop_size + crossPop_size
    matingPoolIndex = random.sample(range(0,popSize) , int(childPop_size))
    return matingPoolIndex, muPop_size , crossPop_size

#----crossover----
def Crossover(Population , crossPop_size , matingPoolIndex):
    print(Population)
    chrom_size = len(Population[0])
    childern_cross = np.zeros((int(crossPop_size), int(chrom_size)))
    i = 0
    while i < crossPop_size:
        CrossPoint = np.random.randint(1 , high = chrom_size - 2)
        x1 = matingPoolIndex[i]
        x2 = matingPoolIndex[i+1]
        Parent1 = Population[x1]
        Parent2 = Population[x2]
        child1 = np.concatenate(Parent1[0:CrossPoint],Parent2[CrossPoint:len(Parent2 - 1)]) 
        child2 = np.concatenate(Parent2[0:CrossPoint],Parent1[CrossPoint:len(Parent1 - 1)])
        childern_cross[i] = child1
        childern_cross[i+1] = child2
        i = i + 2
    return childern_cross

#----mutation----  
def mutate(Population , muPop_size, matingPoolIndex):
    chrom_size = len(Population[0])
    childern_mut = np.zeros((muPop_size, chrom_size))
    crossPop_size = len(matingPoolIndex) - muPop_size - 1
    mu = 0
    sigma = 5
    i = crossPop_size
    j = 0
    while i < len(matingPoolIndex) - 1:
        x = matingPoolIndex[i]
        Parent_single = Population[x]
        Deltax = np.random.normal(mu , sigma)
        randomGenC = np.random.randint(0 , chrom_size)
        muchild = Parent_single.copy()
        newGen = Parent_single[randomGenC] + Deltax
        muchild[randomGenC] = newGen
        
        if muchild[randomGenC] > 1:
            muchild[randomGenC] = 1
        elif muchild[randomGenC] < 0:
            muchild[randomGenC] = 0
            
        
        childern_mut[j] = muchild
        i = i + 1
        j = j + 1
        return childern_mut

#----survivor selection----
def survivor_selection(TotalPop, mainPopsize):

    TotalPopSize = len(TotalPop)
    fitness = np.zeros(TotalPopSize)

    for i in range(TotalPopSize):
      
        alpha = TotalPop[i,0]
        landa = TotalPop[i,1]
        beta = TotalPop[i,2]
        fr = TotalPop[i,3]
        alphafr = TotalPop[i,4]
        k = TotalPop[i,5]

        from ML100KHybrid import calculate_RMSE
        fitness[i] = RMSE
        
        
    Total_bestIndexes = np.argsort(fitness)
    Final_bestIndexes = Total_bestIndexes[0:mainPopsize]
    
    newPop = TotalPop[Final_bestIndexes]
    newPopFitness = fitness[Final_bestIndexes]
    
    return newPop, newPopFitness

#----Genetic main loop----
Population = init_pop()
mainPopSize = popSize
best_fitness_array = np.zeros(generation)
fitn_average_array = np.zeros(generation)

for iteration in range (generation):
    print("generation:" , iteration)
    matingPoolIndexes , muPop_size , crossPop_size = parent_selection()
    offspring_cross = Crossover(Population , crossPop_size , matingPoolIndexes)
    offspring_mu = mutate(Population , muPop_size , matingPoolIndexes)
    TotalPop = np.concatenate((Population ,offspring_cross,offspring_mu),0)
    newPop , newPopFitness = survivor_selection(TotalPop, mainPopSize)
   
    
    bestIndexes = np.argsort(newPopFitness)
    Final_bestIndex = bestIndexes[0]
    
    best_fitness_array[iteration] =  newPopFitness[Final_bestIndex]
    
    Population = newPop
    
    
    
bestIndexes = np.argsort(newPopFitness)
Final_bestIndex = bestIndexes[0]
bestSolution = newPop[Final_bestIndex]
bestSolution_fitness = newPopFitness[Final_bestIndex]
